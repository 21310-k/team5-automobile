H8S,H8/300 SERIES C/C++ COMPILER (V.6.02.01.000)   28-Jan-2025 15:45:55 PAGE   1

************ SOURCE LISTING ************

      Line Pi 0----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0----+----1----+--
FILE NAME: C:\Users\s4exp\Downloads\soft2_test\soft2\soft2\soft2\Soft2\itask_control.c
         1     /****************************************************************************************************************/
         2     /*  FILE        : itask_control.c                                                                               */
         3     /*  DATE        :Tue, Jan 17, 2012                                                                              */
         4     /*  DESCRIPTION :AGVの動作状態管理割り込みタスク                                                                */
         5     /*  CPU TYPE    :H8/3052F                                                                                       */
         6     /****************************************************************************************************************/
         7     #include    "machine.h"                                 /* 組込み関数の定義                                     */
         8     #include    "reg3052.h"                                 /* H8/3052Fの内蔵モジュール定義                         */
         9     #include    "agvdef.h"                                  /* 無人搬送車のデバイス定義                             */
        10     #include    "agvvars.h"                                 /* 無人搬送車の共通変数を定義                           */
        11     #include    "def_monitor_printf.h"                      /* 組込みprintfの定義                                   */
        12     
        13     int i; //全関数で共通な変数
        14     /****************************************************************************************************************/
        15     /*  搬送車動作状態監視・ハンドル制御タスク itask_control                                                        */
        16     /****************************************************************************************************************/
        17     #pragma interrupt itask_control
        18     void    itask_control(void)
        19     {
        20         
        21     }
        22     
        23     /****************************************************************************************************************/
        24     /*  AGVステート管理モジュール agv_state                                                                         */
        25     /****************************************************************************************************************/
        26     void agv_state(void)
        27     {
        28         switch (AGV_STATE) {
        29         case AGV_BOOT:
        30             if (SENS_DATA == 0x00 || SW_DATA == 0x01) {
        31                 AGV_STATE = AGV_BOOT_ALM;
        32             }
        33             if (SENS_DATA != 0x00 && SW_DATA == 0x00) {
        34                 AGV_STATE = AGV_READY;
        35             }
        36             break;
        37     
        38         case AGV_BOOT_ALM:
        39             if (SENS_DATA == 0x00 || SW_DATA == 0x01) {
        40                 AGV_STATE = AGV_BOOT_ALM;
        41             }
        42             if (SENS_DATA != 0x00 && SW_DATA == 0x00) {
        43                 AGV_STATE = AGV_READY;
        44             }
        45             break;
        46     
        47         case AGV_READY:
        48             if (SENS_DATA != 0x00 && SW_DATA == 0x00) {
        49                 AGV_STATE = AGV_READY;
        50             }
        51             if (SENS_DATA == 0x00) {
        52                 AGV_STATE = AGV_READY_ALM;
        53             }
        54             if (SW_DATA == 0x01) {
        55                 AGV_STATE = AGV_RUN_WAIT;
        56                 TSTR |= 0x02; 
        57             }
        58             break;
        59     
        60         case AGV_READY_ALM:
        61             if (SENS_DATA == 0x00 && SW_DATA == 0x00) {
        62                 AGV_STATE = AGV_READY_ALM;
        63             }
        64             if (SENS_DATA != 0x00 && SW_DATA == 0x00) {
        65                 AGV_STATE = AGV_READY;
        66             }
        67             break;
        68     
        69         case AGV_RUN_WAIT:
        70             if (MOTOR_STATE != MOTOR_STOP) {
        71                 AGV_STATE = AGV_RUN;
        72             }
        73             break;
        74     
        75         case AGV_RUN:
        76             if (SW_DATA == 0x01 && MOTOR_STATE != MOTOR_STOP && SENS_DATA!=0x00) {
        77                 AGV_STATE = AGV_RUN;
        78             }
        79             if (SW_DATA == 0x00) {
        80                 AGV_STATE = AGV_STOP_WAIT;
        81             }
        82             if (SENS_DATA == 0x00) {
        83                 AGV_STATE = AGV_RUN_ALM;
        84             }
        85             break;
        86     
        87         case AGV_STOP_WAIT:
        88             if (SENS_DATA == 0x00) {
        89                 AGV_STATE = AGV_RUN_ALM;
        90             }
        91             if (MOTOR_STATE == MOTOR_STOP) {
        92                 AGV_STATE = AGV_READY;
        93             }
        94             break;
        95     
        96         case AGV_RUN_ALM:
        97             if (SENS_DATA == 0x00 && MOTOR_STATE == MOTOR_STOP) {
        98                 AGV_STATE = AGV_RUN_ALM;
        99             }
       100             if (SENS_DATA != 0x00 && SW_DATA == 0x01 && MOTOR_STATE != MOTOR_STOP) {
       101                 AGV_STATE = AGV_RUN;
       102             }
       103             if (SENS_DATA != 0x00 && SW_DATA == 0x01 && MOTOR_STATE == MOTOR_STOP) {
       104                 AGV_STATE = AGV_READY;
       105             }
       106             break;
       107     
       108         default:
       109     
       110             break;
       111     
       112         }
       113     }       
       114     
       115     /****************************************************************************************************************/
       116     //  センサ位置計算モジュール cal_sensor_position
       117     // 引数：なし
       118     // 戻り値：センサの位置情報                                                             */
       119     /****************************************************************************************************************/
       120     
       121     unsigned char cal_sensor_position(void)
       122     {
       123         // weight(i)=16+32*iの計算式に則り、重みを設定
       124         unsigned char weight[8] = { 16, 32, 48, 64, 80, 96, 112, 128 };
       125         // センサ入力を取得
       126         unsigned char sens_input = bios_sensor_input();
       127         // 必要な変数を定義
       128         unsigned char molecule = 0;
       129         unsigned char denominator = 0;
       130         unsigned char position = 0;
       131     
       132         // 各桁について見ていく
       133         for (i = 0; i < 8; i++) {
       134             // sens_inputのi桁目が1の場合
       135             if (sens_input & (1 << i)) {
       136                 // 分子に重みを加算
       137                 molecule += weight[i];
       138                 // 分母を加算
       139                 denominator ++;
       140             }
       141         }
       142     
       143         //  positionを算出
       144         position = molecule / denominator;
       145         // positionを返す
       146         return position;
       147         
       148     }
       149     
       150     /****************************************************************************************************************/
       151     //  ハンドル制御モジュール handle_control
       152     // 引数：cal_sensor_pos()で算出した位置情報
       153     // 戻り値：なし                                                                     */
       154     /****************************************************************************************************************/
       155     
       156     void handle_control(unsigned char spos)
       157     {
       158         // ずれ量diffを求める
       159         unsigned char diff = spos - HANDLE_CENTER;
       160         // 現在のハンドル切れ角adを取得
       161         unsigned char ad = bios_ad_input();
       162         // 変数定義
       163         unsigned char da_output = 0;
       164     
       165         // dに17/32を乗じたものを現在のハンドル切れ角adに加えたものが制御値に求められる。
       166         da_output = diff * 17 / 32 + ad;
       167         
       168         // 制御値を出力
       169         bios_da_output(da_output);
       170     }


H8S,H8/300 SERIES C/C++ COMPILER (V.6.02.01.000)   28-Jan-2025 15:45:55 PAGE   1

******* SECTION SIZE INFORMATION *******

PROGRAM  SECTION(P):                                0x000001C4 Byte(s)
CONSTANT SECTION(C):                                0x00000000 Byte(s)
DATA     SECTION(D):                                0x00000008 Byte(s)
BSS      SECTION(B):                                0x00000002 Byte(s)

TOTAL PROGRAM  SECTION: 0x000001C4 Byte(s)
TOTAL CONSTANT SECTION: 0x00000000 Byte(s)
TOTAL DATA     SECTION: 0x00000008 Byte(s)
TOTAL BSS      SECTION: 0x00000002 Byte(s)

    TOTAL PROGRAM SIZE: 0x000001CE Byte(s)



** ASSEMBLER/LINKAGE EDITOR LIMITS INFORMATION **

NUMBER OF EXTERNAL REFERENCE  SYMBOLS:       10 
NUMBER OF EXTERNAL DEFINITION SYMBOLS:        5 
NUMBER OF INTERNAL/EXTERNAL SYMBOLS:         44 



**** COMPILE CONDITION INFORMATION ****

COMMAND LINE: -cpu=300HA:20 -object=C:\Users\s4exp\Downloads\soft2_test\soft2\soft2\soft2\Soft2\Debug\itask_control.obj -debug -list=C:\Users\s4exp\Downloads\soft2_test\soft2\soft2\soft2\Soft2\Debug\itask_control.lst -show=tab=4 -chgincpath C:\Users\s4exp\Downloads\soft2_test\soft2\soft2\soft2\Soft2\itask_control.c -lang=c -nologo
CPU         : 300ha:20
