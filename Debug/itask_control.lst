H8S,H8/300 SERIES C/C++ COMPILER (V.6.02.01.000)    5-Feb-2025 16:18:04 PAGE   1

************ SOURCE LISTING ************

      Line Pi 0----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0----+----1----+--
FILE NAME: C:\Users\s4exp\Desktop\R7a_team5\test_merge\Soft2\itask_control.c
         1     /****************************************************************************************************************/
         2     /*  FILE        : itask_control.c                                                                               */
         3     /*  DATE        :Tue, Jan 17, 2012                                                                              */
         4     /*  DESCRIPTION :AGVの動作状態管理割り込みタスク                                                              */
         5     /*  CPU TYPE    :H8/3052F                                                                                       */
         6     /****************************************************************************************************************/
         7     #include    "machine.h"                                 /* 組込み関数の定義                                     */
         8     #include    "reg3052.h"                                 /* H8/3052Fの内蔵モジュール定義                           */
         9     #include    "agvdef.h"                                  /* 無人搬送車のデバイス定義                             */
        10     #include    "agvvars.h"                                 /* 無人搬送車の共通変数を定義                            */
        11     #include    "def_monitor_printf.h"                      /* 組込みprintfの定義                                 */
        12     
        13     
        14     
        15     
        16     /****************************************************************************************************************/
        17     /*  搬送車動作状態監視・ハンドル制御タスク itask_control                                                       */
        18     /****************************************************************************************************************/
        19     //関数の仮宣言
        20     void agv_state(void);
        21     unsigned char cal_sensor_position(void);
        22     void handle_control(unsigned char spos);
        23     
        24     //変数の定義
        25     unsigned char calculated_pos;
        26     int i;
        27     
        28     #pragma interrupt itask_control
        29     void    itask_control(void)
        30     {
        31         //優先度1の割り込みを許可
        32         and_ccr(~0x40);
        33         
        34         // ①ステートのフェッチと変更 (agv_state())
        35         // ②センサ位置の計算(cal_sensor_position())
        36         // ③ハンドル制御(handle_control())
        37         //以上3つをitask_controlが割り込まれた際に実行する。
        38         agv_state();
        39         calculated_pos = cal_sensorposition();
        40         handle_control(calculated_pos);
        41         
        42         //ITU2の割り込みフラグをクリア
        43         TSR2 &= ~0x01;
        44         
        45     }
        46     
        47     /****************************************************************************************************************/
        48     /*  AGVステート管理モジュール agv_state                                                                            */
        49     /****************************************************************************************************************/
        50     void agv_state(void)
        51     {
        52         //センサ検出とはSENS_DATAが0x00の値以外であること
        53         switch (AGV_STATE) {
        54         case AGV_BOOT:
        55             if (SENS_DATA == 0x00 || SW_DATA == 0x01) {
        56                 AGV_STATE = AGV_BOOT_ALM;
        57             }
        58             if (SENS_DATA != 0x00 && SW_DATA == 0x00) {
        59                 AGV_STATE = AGV_READY;
        60             }
        61             break;
        62     
        63         case AGV_BOOT_ALM:
        64         
        65             if (SENS_DATA == 0x00 || SW_DATA == 0x01) {
        66                 AGV_STATE = AGV_BOOT_ALM;
        67             }
        68             if (SENS_DATA != 0x00 && SW_DATA == 0x00) {
        69                 AGV_STATE = AGV_READY;
        70             }
        71             break;
        72     
        73         case AGV_READY:
        74             if (SENS_DATA != 0x00 && SW_DATA == 0x00) {
        75                 AGV_STATE = AGV_READY;
        76             }
        77             if (SENS_DATA == 0x00) {
        78                 AGV_STATE = AGV_READY_ALM;
        79             }
        80             if (SW_DATA == 0x01) {
        81                 AGV_STATE = AGV_RUN_WAIT;
        82                 TSTR |= 0x02; 
        83             }
        84             break;
        85     
        86         case AGV_READY_ALM:
        87             if (SENS_DATA == 0x00 && SW_DATA == 0x00) {
        88                 AGV_STATE = AGV_READY_ALM;
        89             }
        90             if (SENS_DATA != 0x00 && SW_DATA == 0x00) {
        91                 AGV_STATE = AGV_READY;
        92             }
        93             break;
        94     
        95         case AGV_RUN_WAIT:
        96             if (MOTOR_STATE != MOTOR_STOP) {
        97                 AGV_STATE = AGV_RUN;
        98             }
        99             break;
       100     
       101         case AGV_RUN:
       102     
       103             if (SW_DATA == 0x00) {
       104                 AGV_STATE = AGV_STOP_WAIT;
       105             }
       106             if (SW_DATA == 0x01 && SENS_DATA == 0x00) {
       107                 AGV_STATE = AGV_RUN_ALM;
       108             }
       109             if (SW_DATA == 0x01 && MOTOR_STATE != MOTOR_STOP && SENS_DATA!=0x00) {
       110                 AGV_STATE = AGV_RUN;
       111             }
       112             break;
       113     
       114         case AGV_STOP_WAIT:
       115             if (SENS_DATA == 0x00) {
       116                 AGV_STATE = AGV_RUN_ALM;
       117             }
       118             if (MOTOR_STATE == MOTOR_STOP) {
       119                 AGV_STATE = AGV_READY;
       120             }
       121             break;
       122     
       123         case AGV_RUN_ALM:
       124             if (SENS_DATA == 0x00 && MOTOR_STATE == MOTOR_STOP) {
       125                 AGV_STATE = AGV_RUN_ALM;
       126             }
       127             if (SENS_DATA != 0x00 && SW_DATA == 0x01 && MOTOR_STATE != MOTOR_STOP) {
       128                 AGV_STATE = AGV_RUN;
       129             }
       130             if (SENS_DATA != 0x00 && SW_DATA == 0x01 && MOTOR_STATE == MOTOR_STOP) {
       131                 AGV_STATE = AGV_READY;
       132             }
       133             break;
       134     
       135         default:
       136     
       137             break;
       138     
       139         }
       140     }       
       141     
       142     /****************************************************************************************************************/
       143     //  センサ位置計算モジュール cal_sensor_position
       144     // 引数：なし
       145     // 戻り値：センサの位置情報                                                             */
       146     /****************************************************************************************************************/
       147     
       148     unsigned char cal_sensor_position(void)
       149     {
       150         // weight(i)=16+32*iの計算式に則り、重みを設定
       151         unsigned char weight[8] = {16, 48, 80, 112, 144, 176, 208, 240};
       152         // センサ入力を取得
       153         unsigned char sens_input = bios_sensor_input();
       154         // 必要な変数を定義
       155         unsigned int molecule = 0;
       156         unsigned int denominator = 0;
       157         unsigned char position = 0;
       158     
       159         // 各桁について見ていく
       160         for (i = 0; i < 8; i++) {
       161             // sens_inputのi桁目が1の場合
       162             if ((sens_input & (1 << i))!=0) {
       163                 // 分子に重みを加算
       164                 molecule += weight[i];
       165                 // 分母を加算
       166                 denominator ++;
       167             }
       168         }
       169     
       170         //  positionを算出
       171         if(denominator == 0){return 0;}
       172         position =(unsigned char)( molecule / denominator);
       173         printf("postion = %d\n",position);
       174         // positionを返す
       175         return position;
       176         
       177     }
       178     
       179     /****************************************************************************************************************/
       180     //  ハンドル制御モジュール handle_control
       181     // 引数：cal_sensor_pos()で算出した位置情報
       182     // 戻り値：なし                                                                       */
       183     /****************************************************************************************************************/
       184     //sposはcal_sensor_pos()で算出した位置情報
       185     void handle_control(unsigned char spos)
       186     {
       187         // ずれ量diffを求める
       188         int diff = spos - HANDLE_CENTER;
       189         // 現在のハンドル切れ角adを取得
       190         unsigned char ad = bios_ad_input();
       191         // 変数定義
       192         int da_output = 0;
       193     
       194         // dに17/32を乗じたものを現在のハンドル切れ角adに加えたものが制御値に求められる。
       195         
       196         da_output = diff * 17 / 32;
       197         da_output = da_output + (int)(ad);
       198         
       199         if (da_output < 0){da_output = 0;}
       200         if (da_output > 255){da_output = 255;}
       201         
       202         // 制御値を出力
       203         bios_led_output(ad);
       204         bios_da_output(da_output);
       205     }


H8S,H8/300 SERIES C/C++ COMPILER (V.6.02.01.000)    5-Feb-2025 16:18:04 PAGE   1

******* SECTION SIZE INFORMATION *******

PROGRAM  SECTION(P):                                0x00000236 Byte(s)
CONSTANT SECTION(C):                                0x0000000E Byte(s)
DATA     SECTION(D):                                0x00000008 Byte(s)
BSS      SECTION(B):                                0x00000003 Byte(s)

TOTAL PROGRAM  SECTION: 0x00000236 Byte(s)
TOTAL CONSTANT SECTION: 0x0000000E Byte(s)
TOTAL DATA     SECTION: 0x00000008 Byte(s)
TOTAL BSS      SECTION: 0x00000003 Byte(s)

    TOTAL PROGRAM SIZE: 0x0000024F Byte(s)



** ASSEMBLER/LINKAGE EDITOR LIMITS INFORMATION **

NUMBER OF EXTERNAL REFERENCE  SYMBOLS:       12 
NUMBER OF EXTERNAL DEFINITION SYMBOLS:        6 
NUMBER OF INTERNAL/EXTERNAL SYMBOLS:         53 



**** COMPILE CONDITION INFORMATION ****

COMMAND LINE: -cpu=300HA:20 -object=C:\Users\s4exp\Desktop\R7a_team5\test_merge\Soft2\Debug\itask_control.obj -debug -list=C:\Users\s4exp\Desktop\R7a_team5\test_merge\Soft2\Debug\itask_control.lst -show=tab=4 -chgincpath C:\Users\s4exp\Desktop\R7a_team5\test_merge\Soft2\itask_control.c -lang=c -nologo
CPU         : 300ha:20
